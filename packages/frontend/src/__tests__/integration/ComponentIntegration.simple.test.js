import React from 'react';
import { render, screen, waitFor, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import App from '../../App';

// Add jest-axe matcher
expect.extend(toHaveNoViolations);\n\n// Error Boundary Component for testing\nclass TestErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div role=\"alert\">\n          <h2>Something went wrong</h2>\n          <p>Error: {this.state.error?.message}</p>\n          <button onClick={() => this.setState({ hasError: false, error: null })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Component that throws errors for testing\nconst ErrorThrowingComponent = ({ shouldThrow, errorMessage }) => {\n  if (shouldThrow) {\n    throw new Error(errorMessage || 'Test error');\n  }\n  return <div>No error</div>;\n};\n\n// Mock server with various error scenarios\nconst server = setupServer(\n  rest.get('/api/tasks', (req, res, ctx) => {\n    return res(ctx.status(200), ctx.json({ tasks: [], total: 0, page: 1, totalPages: 0 }));\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('Component Integration and Error Handling Tests', () => {\n  describe('Error Boundary Testing', () => {\n    test('should catch and display component errors', () => {\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      render(\n        <TestErrorBoundary>\n          <ErrorThrowingComponent shouldThrow={true} errorMessage=\"Test component error\" />\n        </TestErrorBoundary>\n      );\n      \n      expect(screen.getByRole('alert')).toBeInTheDocument();\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n      expect(screen.getByText(/Test component error/)).toBeInTheDocument();\n      \n      consoleError.mockRestore();\n    });\n\n    test('should recover from errors when reset', async () => {\n      const user = userEvent.setup();\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      const { rerender } = render(\n        <TestErrorBoundary>\n          <ErrorThrowingComponent shouldThrow={true} />\n        </TestErrorBoundary>\n      );\n      \n      expect(screen.getByRole('alert')).toBeInTheDocument();\n      \n      // Click try again\n      await user.click(screen.getByText('Try Again'));\n      \n      // Rerender with non-throwing component\n      rerender(\n        <TestErrorBoundary>\n          <ErrorThrowingComponent shouldThrow={false} />\n        </TestErrorBoundary>\n      );\n      \n      expect(screen.getByText('No error')).toBeInTheDocument();\n      expect(screen.queryByRole('alert')).not.toBeInTheDocument();\n      \n      consoleError.mockRestore();\n    });\n\n    test('should render App component without crashing', async () => {\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      await act(async () => {\n        render(\n          <TestErrorBoundary>\n            <App />\n          </TestErrorBoundary>\n        );\n      });\n\n      // Wait for the component to render\n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      });\n      \n      consoleError.mockRestore();\n    });\n  });\n\n  describe('Basic Accessibility', () => {\n    test('should provide basic ARIA structure', async () => {\n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      });\n\n      // Check for basic ARIA structure\n      expect(screen.getByRole('main')).toBeInTheDocument();\n    });\n\n    test('should support basic keyboard navigation', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      });\n\n      // Try basic tab navigation\n      await user.tab();\n      \n      // Should not throw errors\n      expect(screen.getByRole('main')).toBeInTheDocument();\n    });\n\n    test('should pass basic accessibility audit', async () => {\n      const { container } = await act(async () => {\n        return render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      });\n\n      // Run basic accessibility check\n      const results = await axe(container, {\n        rules: {\n          // Enable essential accessibility rules\n          'color-contrast': { enabled: true },\n          'landmark-one-main': { enabled: true },\n          'page-has-heading-one': { enabled: false }, // May not have h1 in simple app\n        }\n      });\n\n      expect(results).toHaveNoViolations();\n    });\n  });\n\n  describe('Basic Functionality', () => {\n    test('should render main application structure', async () => {\n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      });\n\n      // Check basic app structure\n      expect(screen.getByRole('main')).toBeInTheDocument();\n    });\n\n    test('should handle basic user interactions safely', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      });\n\n      // Check if any interactive elements are present\n      const buttons = screen.queryAllByRole('button');\n      const textboxes = screen.queryAllByRole('textbox');\n      \n      // If there are interactive elements, test basic interaction\n      if (buttons.length > 0) {\n        // Try clicking the first button if it exists\n        await user.click(buttons[0]);\n        // Just verify it doesn't crash\n        expect(screen.getByRole('main')).toBeInTheDocument();\n      }\n      \n      if (textboxes.length > 0) {\n        // Test typing in the first text input\n        await user.type(textboxes[0], 'Test input');\n        expect(textboxes[0]).toHaveValue('Test input');\n      }\n    });\n  });\n});