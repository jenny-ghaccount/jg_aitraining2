import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from '../../App';

// Mock fetch for API calls
global.fetch = jest.fn();

describe('Component Integration Tests', () => {
  beforeEach(() => {
    fetch.mockClear();
    fetch.mockResolvedValue({
      ok: true,
      json: async () => ([])
    });
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  test('should render App component without crashing', async () => {
    render(<App />);
    
    expect(screen.getByText('Todo App')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.queryByText('Loading tasks...')).not.toBeInTheDocument();
    });
  });

  test('should pass basic accessibility audit', async () => {
    const { container } = render(<App />);
    
    await waitFor(() => {
      expect(screen.getByText('TODO App')).toBeInTheDocument();
    });

    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  test('should handle form interactions', async () => {
    const user = userEvent.setup();
    render(<App />);
    
    // Find the task input and button
    const taskInput = screen.getByRole('textbox');
    const addButton = screen.getByRole('button', { name: /add task/i });
    
    // Type a task and submit
    await user.type(taskInput, 'Test task');
    expect(taskInput).toHaveValue('Test task');
    
    await user.click(addButton);
    
    // Input should be cleared after submission
    expect(taskInput).toHaveValue('');
  });

  test('should support keyboard navigation', async () => {
    const user = userEvent.setup();
    render(<App />);
    
    // Tab through focusable elements
    await user.tab();
    const firstElement = document.activeElement;
    
    await user.tab();
    const secondElement = document.activeElement;
    
    // Should move focus to different elements
    expect(firstElement).not.toBe(secondElement);
  });

  test('should handle Enter key form submission', async () => {
    const user = userEvent.setup();
    render(<App />);
    
    const taskInput = screen.getByRole('textbox');
    
    // Type task and press Enter
    await user.type(taskInput, 'Task via Enter{enter}');
    
    // Input should be cleared
    expect(taskInput).toHaveValue('');
  });
});\nimport { render, screen, waitFor, act } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport App from '../../App';\n\n// Add jest-axe matcher\nexpect.extend(toHaveNoViolations);\n\n// Error Boundary Component for testing\nclass TestErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div role=\"alert\">\n          <h2>Something went wrong</h2>\n          <p>Error: {this.state.error?.message}</p>\n          <button onClick={() => this.setState({ hasError: false, error: null })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Component that throws errors for testing\nconst ErrorThrowingComponent = ({ shouldThrow, errorMessage }) => {\n  if (shouldThrow) {\n    throw new Error(errorMessage || 'Test error');\n  }\n  return <div>No error</div>;\n};\n\n// Mock server with various error scenarios\nconst server = setupServer(\n  rest.get('/api/tasks', (req, res, ctx) => {\n    return res(ctx.status(200), ctx.json([]));\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('Component Integration and Error Handling Tests', () => {\n  describe('Error Boundary Testing', () => {\n    test('should catch and display component errors', () => {\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      render(\n        <TestErrorBoundary>\n          <ErrorThrowingComponent shouldThrow={true} errorMessage=\"Test component error\" />\n        </TestErrorBoundary>\n      );\n      \n      expect(screen.getByRole('alert')).toBeInTheDocument();\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n      expect(screen.getByText(/Test component error/)).toBeInTheDocument();\n      \n      consoleError.mockRestore();\n    });\n\n    test('should recover from errors when reset', async () => {\n      const user = userEvent.setup();\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      const { rerender } = render(\n        <TestErrorBoundary>\n          <ErrorThrowingComponent shouldThrow={true} />\n        </TestErrorBoundary>\n      );\n      \n      expect(screen.getByRole('alert')).toBeInTheDocument();\n      \n      // Click try again\n      await user.click(screen.getByText('Try Again'));\n      \n      // Rerender with non-throwing component\n      rerender(\n        <TestErrorBoundary>\n          <ErrorThrowingComponent shouldThrow={false} />\n        </TestErrorBoundary>\n      );\n      \n      expect(screen.getByText('No error')).toBeInTheDocument();\n      expect(screen.queryByRole('alert')).not.toBeInTheDocument();\n      \n      consoleError.mockRestore();\n    });\n\n    test('should handle API errors gracefully in App component', async () => {\n      server.use(\n        rest.get('/api/tasks', (req, res, ctx) => {\n          return res(ctx.status(500), ctx.json({ error: 'Server error' }));\n        })\n      );\n\n      await act(async () => {\n        render(\n          <TestErrorBoundary>\n            <App />\n          </TestErrorBoundary>\n        );\n      });\n\n      await waitFor(() => {\n        expect(screen.getByRole('alert')).toBeInTheDocument();\n        expect(screen.getByText(/failed to fetch tasks/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Accessibility Edge Cases', () => {\n    test('should maintain focus management during navigation', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Tab through the interface\n      await user.tab();\n      const firstFocusable = document.activeElement;\n      \n      await user.tab();\n      const secondFocusable = document.activeElement;\n      \n      expect(firstFocusable).not.toBe(secondFocusable);\n      expect(document.activeElement).toBe(secondFocusable);\n    });\n\n    test('should handle keyboard shortcuts correctly', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Test keyboard shortcut for adding task (assuming Ctrl+N)\n      await user.keyboard('{Control>}n{/Control}');\n      \n      // Should open task form\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n    });\n\n    test('should provide proper ARIA live regions for status updates', async () => {\n      const user = userEvent.setup();\n      \n      server.use(\n        rest.post('/api/tasks', (req, res, ctx) => {\n          return res(\n            ctx.delay(100),\n            ctx.status(201), \n            ctx.json({ id: 1, title: req.body.title, completed: false })\n          );\n        })\n      );\n\n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Open task form\n      const addButton = screen.getByRole('button', { name: /add/i });\n      await user.click(addButton);\n\n      // Fill and submit form\n      await user.type(screen.getByLabelText(/title/i), 'New Task');\n      await user.click(screen.getByRole('button', { name: /create/i }));\n\n      // Should show loading state\n      expect(screen.getByRole('status')).toBeInTheDocument();\n\n      // Should show success message\n      await waitFor(() => {\n        expect(screen.getByRole('status')).toHaveTextContent(/success/i);\n      });\n    });\n\n    test('should handle high contrast mode correctly', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      // Toggle to high contrast theme\n      const themeButton = screen.getByRole('button', { name: /theme/i });\n      await user.click(themeButton);\n      \n      // Should apply high contrast styles\n      const container = screen.getByRole('main');\n      expect(container).toHaveAttribute('data-theme', expect.stringMatching(/contrast/));\n    });\n\n    test('should support screen reader announcements', async () => {\n      await act(async () => {\n        render(<App />);\n      });\n\n      // Check for proper ARIA labels\n      expect(screen.getByRole('banner')).toBeInTheDocument(); // AppBar\n      expect(screen.getByRole('main')).toBeInTheDocument();   // Main content\n      \n      // Navigation should be properly labeled\n      const navigation = screen.queryByRole('navigation');\n      if (navigation) {\n        expect(navigation).toHaveAttribute('aria-label');\n      }\n\n      // Buttons should have accessible names\n      const buttons = screen.getAllByRole('button');\n      buttons.forEach(button => {\n        expect(\n          button.getAttribute('aria-label') || \n          button.textContent ||\n          button.getAttribute('title')\n        ).toBeTruthy();\n      });\n    });\n\n    test('should handle reduced motion preferences', async () => {\n      // Mock prefers-reduced-motion\n      Object.defineProperty(window, 'matchMedia', {\n        writable: true,\n        value: jest.fn().mockImplementation(query => ({\n          matches: query === '(prefers-reduced-motion: reduce)',\n          media: query,\n          onchange: null,\n          addListener: jest.fn(),\n          removeListener: jest.fn(),\n          addEventListener: jest.fn(),\n          removeEventListener: jest.fn(),\n          dispatchEvent: jest.fn(),\n        })),\n      });\n\n      await act(async () => {\n        render(<App />);\n      });\n\n      // Should apply reduced motion styles\n      const container = screen.getByRole('main');\n      const styles = window.getComputedStyle(container);\n      \n      // This would depend on your CSS implementation\n      // expect(styles.animation).toBe('none');\n      expect(container).toBeInTheDocument();\n    });\n  });\n\n  describe('State Management Integration', () => {\n    test('should handle optimistic updates correctly', async () => {\n      const user = userEvent.setup();\n      \n      server.use(\n        rest.post('/api/tasks', (req, res, ctx) => {\n          return res(\n            ctx.delay(1000), // Slow response\n            ctx.status(201),\n            ctx.json({ id: Date.now(), title: req.body.title, completed: false })\n          );\n        })\n      );\n\n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Add task\n      const addButton = screen.getByRole('button', { name: /add/i });\n      await user.click(addButton);\n      \n      await user.type(screen.getByLabelText(/title/i), 'Optimistic Task');\n      await user.click(screen.getByRole('button', { name: /create/i }));\n\n      // Task should appear immediately (optimistic update)\n      expect(screen.getByText('Optimistic Task')).toBeInTheDocument();\n      \n      // Should show loading state\n      expect(screen.getByRole('status')).toBeInTheDocument();\n    });\n\n    test('should handle state conflicts during concurrent operations', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Perform multiple operations quickly\n      const addButton = screen.getByRole('button', { name: /add/i });\n      \n      // Click add button multiple times rapidly\n      await user.click(addButton);\n      await user.click(addButton);\n      await user.click(addButton);\n      \n      // Should handle multiple dialogs gracefully (only show one)\n      const dialogs = screen.getAllByRole('dialog');\n      expect(dialogs).toHaveLength(1);\n    });\n\n    test('should maintain scroll position during updates', async () => {\n      // Create many tasks to enable scrolling\n      const manyTasks = Array.from({ length: 50 }, (_, i) => ({\n        id: i + 1,\n        title: `Task ${i + 1}`,\n        completed: false,\n        dueDate: null,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      }));\n\n      server.use(\n        rest.get('/api/tasks', (req, res, ctx) => {\n          return res(ctx.status(200), ctx.json(manyTasks));\n        })\n      );\n\n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n      });\n\n      // Simulate scroll\n      const taskList = screen.getByRole('list');\n      taskList.scrollTop = 500;\n      \n      // Trigger update\n      const user = userEvent.setup();\n      const refreshButton = screen.getByRole('button', { name: /refresh/i });\n      await user.click(refreshButton);\n\n      // Scroll position should be maintained\n      expect(taskList.scrollTop).toBe(500);\n    });\n  });\n\n  describe('Performance Edge Cases', () => {\n    test('should handle rapid user interactions without performance issues', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      const startTime = performance.now();\n      \n      // Perform many rapid interactions\n      const themeButton = screen.getByRole('button', { name: /theme/i });\n      \n      for (let i = 0; i < 10; i++) {\n        await user.click(themeButton);\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      // Should complete within reasonable time (adjust threshold as needed)\n      expect(totalTime).toBeLessThan(2000);\n    });\n\n    test('should debounce search inputs correctly', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      const searchInput = screen.getByRole('textbox', { name: /search/i });\n      \n      // Type rapidly\n      await user.type(searchInput, 'rapid typing test', { delay: 50 });\n      \n      // Should debounce API calls (mock would show this)\n      // This test would need actual search functionality implemented\n      expect(searchInput).toHaveValue('rapid typing test');\n    });\n  });\n\n  describe('Mobile and Responsive Behavior', () => {\n    test('should handle touch interactions correctly', async () => {\n      // Mock touch environment\n      Object.defineProperty(window.navigator, 'maxTouchPoints', {\n        writable: true,\n        value: 5\n      });\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      // Should apply touch-friendly styles\n      const buttons = screen.getAllByRole('button');\n      buttons.forEach(button => {\n        const styles = window.getComputedStyle(button);\n        // Touch targets should be at least 44px (depends on CSS implementation)\n        expect(parseInt(styles.minHeight) || 44).toBeGreaterThanOrEqual(44);\n      });\n    });\n\n    test('should handle viewport changes gracefully', async () => {\n      await act(async () => {\n        render(<App />);\n      });\n\n      // Mock viewport resize\n      global.innerWidth = 320;\n      global.innerHeight = 568;\n      global.dispatchEvent(new Event('resize'));\n\n      // Should adapt to small screen\n      const container = screen.getByRole('main');\n      expect(container).toBeInTheDocument();\n      \n      // Navigation should be responsive\n      const navigation = screen.queryByRole('navigation');\n      if (navigation) {\n        // Should show mobile navigation pattern\n        expect(navigation).toHaveClass(/mobile/);\n      }\n    });\n  });\n\n  describe('Comprehensive Accessibility Testing', () => {\n    test('should pass comprehensive accessibility audit', async () => {\n      const { container } = await act(async () => {\n        return render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      const results = await axe(container, {\n        rules: {\n          // Enable additional accessibility rules\n          'color-contrast-enhanced': { enabled: true },\n          'focus-order-semantics': { enabled: true },\n          'landmark-no-duplicate-banner': { enabled: true },\n          'landmark-no-duplicate-contentinfo': { enabled: true },\n          'page-has-heading-one': { enabled: true },\n          'region': { enabled: true }\n        }\n      });\n\n      expect(results).toHaveNoViolations();\n    });\n\n    test('should support keyboard-only navigation completely', async () => {\n      const user = userEvent.setup();\n      \n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Tab through entire interface\n      const interactiveElements = [\n        ...screen.getAllByRole('button'),\n        ...screen.getAllByRole('textbox'),\n        ...screen.getAllByRole('checkbox')\n      ];\n\n      for (let i = 0; i < interactiveElements.length; i++) {\n        await user.tab();\n        expect(document.activeElement).toBe(interactiveElements[i]);\n      }\n    });\n\n    test('should provide meaningful error messages for screen readers', async () => {\n      const user = userEvent.setup();\n      \n      server.use(\n        rest.post('/api/tasks', (req, res, ctx) => {\n          return res(\n            ctx.status(400),\n            ctx.json({ error: 'Title is required and cannot be empty' })\n          );\n        })\n      );\n\n      await act(async () => {\n        render(<App />);\n      });\n\n      await waitFor(() => {\n        expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n      });\n\n      // Try to submit invalid form\n      const addButton = screen.getByRole('button', { name: /add/i });\n      await user.click(addButton);\n      \n      const submitButton = screen.getByRole('button', { name: /create/i });\n      await user.click(submitButton);\n\n      // Error should be announced to screen readers\n      const errorAlert = await screen.findByRole('alert');\n      expect(errorAlert).toHaveTextContent(/title is required/i);\n      expect(errorAlert).toHaveAttribute('aria-live', 'polite');\n    });\n  });\n});