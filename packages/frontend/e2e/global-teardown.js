const { chromium } = require('@playwright/test');\nconst path = require('path');\nconst fs = require('fs');\n\n// Global teardown function\nasync function globalTeardown(config) {\n  console.log('üèÅ Starting global test teardown...');\n  \n  try {\n    // Clean up test data\n    console.log('üßπ Cleaning up test data...');\n    await cleanupTestData();\n    \n    // Generate test summary\n    console.log('üìä Generating test summary...');\n    await generateTestSummary();\n    \n    // Archive test artifacts if in CI\n    if (process.env.CI) {\n      console.log('üì¶ Archiving test artifacts...');\n      await archiveArtifacts();\n    }\n    \n    // Clean up temporary files\n    console.log('üóëÔ∏è  Cleaning up temporary files...');\n    await cleanupTempFiles();\n    \n    console.log('‚úÖ Global teardown completed successfully!');\n    \n  } catch (error) {\n    console.error('‚ùå Global teardown failed:', error);\n    // Don't throw error in teardown to avoid masking test failures\n  }\n}\n\n// Clean up test data from database\nasync function cleanupTestData() {\n  try {\n    const apiUrl = process.env.API_URL || 'http://localhost:3001';\n    \n    const browser = await chromium.launch();\n    const context = await browser.newContext();\n    const page = await context.newPage();\n    \n    try {\n      // Get all tasks that were created during testing\n      const response = await page.request.get(`${apiUrl}/api/tasks?search=Test`);\n      \n      if (response.ok()) {\n        const data = await response.json();\n        \n        if (data.tasks && data.tasks.length > 0) {\n          const testTaskIds = data.tasks\n            .filter(task => \n              task.title.includes('Test') ||\n              task.title.includes('E2E') ||\n              task.title.includes('Keyboard') ||\n              task.title.includes('Performance') ||\n              task.description.includes('test')\n            )\n            .map(task => task.id);\n          \n          if (testTaskIds.length > 0) {\n            await page.request.delete(`${apiUrl}/api/tasks/bulk`, {\n              headers: { 'Content-Type': 'application/json' },\n              data: { taskIds: testTaskIds }\n            });\n            \n            console.log(`üóëÔ∏è  Cleaned up ${testTaskIds.length} test tasks`);\n          }\n        }\n      }\n      \n    } finally {\n      await context.close();\n      await browser.close();\n    }\n    \n  } catch (error) {\n    console.warn('‚ö†Ô∏è  Could not clean up test data:', error.message);\n  }\n}\n\n// Generate test summary report\nasync function generateTestSummary() {\n  try {\n    const reportDir = path.resolve(process.cwd(), 'playwright-report');\n    \n    if (!fs.existsSync(reportDir)) {\n      return;\n    }\n    \n    const resultsFile = path.join(reportDir, 'results.json');\n    \n    if (fs.existsSync(resultsFile)) {\n      const results = JSON.parse(fs.readFileSync(resultsFile, 'utf8'));\n      \n      const summary = {\n        timestamp: new Date().toISOString(),\n        totalTests: results.suites?.reduce((total, suite) => \n          total + (suite.specs?.length || 0), 0) || 0,\n        passed: 0,\n        failed: 0,\n        skipped: 0,\n        duration: results.stats?.duration || 0\n      };\n      \n      // Count test results\n      if (results.suites) {\n        results.suites.forEach(suite => {\n          if (suite.specs) {\n            suite.specs.forEach(spec => {\n              if (spec.tests) {\n                spec.tests.forEach(test => {\n                  if (test.results) {\n                    test.results.forEach(result => {\n                      switch (result.status) {\n                        case 'passed':\n                          summary.passed++;\n                          break;\n                        case 'failed':\n                          summary.failed++;\n                          break;\n                        case 'skipped':\n                          summary.skipped++;\n                          break;\n                      }\n                    });\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n      \n      // Write summary\n      const summaryFile = path.join(reportDir, 'summary.json');\n      fs.writeFileSync(summaryFile, JSON.stringify(summary, null, 2));\n      \n      console.log('üìà Test Summary:');\n      console.log(`   Total: ${summary.totalTests}`);\n      console.log(`   Passed: ${summary.passed}`);\n      console.log(`   Failed: ${summary.failed}`);\n      console.log(`   Skipped: ${summary.skipped}`);\n      console.log(`   Duration: ${Math.round(summary.duration / 1000)}s`);\n      \n      // Generate markdown summary for GitHub Actions\n      if (process.env.GITHUB_STEP_SUMMARY) {\n        const markdownSummary = `\n## üé≠ Playwright Test Results\n\n| Metric | Value |\n|--------|-------|\n| Total Tests | ${summary.totalTests} |\n| ‚úÖ Passed | ${summary.passed} |\n| ‚ùå Failed | ${summary.failed} |\n| ‚è≠Ô∏è Skipped | ${summary.skipped} |\n| ‚è±Ô∏è Duration | ${Math.round(summary.duration / 1000)}s |\n\n${summary.failed > 0 ? '‚ùå Some tests failed. Check the detailed report.' : '‚úÖ All tests passed!'}\n`;\n        \n        fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, markdownSummary);\n      }\n    }\n    \n  } catch (error) {\n    console.warn('‚ö†Ô∏è  Could not generate test summary:', error.message);\n  }\n}\n\n// Archive test artifacts for CI\nasync function archiveArtifacts() {\n  try {\n    const artifactsDir = path.resolve(process.cwd(), 'playwright-artifacts');\n    const reportDir = path.resolve(process.cwd(), 'playwright-report');\n    \n    // Create archive directory structure\n    const archiveDir = path.resolve(process.cwd(), 'test-archives');\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const runArchiveDir = path.join(archiveDir, `run-${timestamp}`);\n    \n    if (!fs.existsSync(runArchiveDir)) {\n      fs.mkdirSync(runArchiveDir, { recursive: true });\n    }\n    \n    // Copy artifacts\n    if (fs.existsSync(artifactsDir)) {\n      await copyDirectory(artifactsDir, path.join(runArchiveDir, 'artifacts'));\n    }\n    \n    if (fs.existsSync(reportDir)) {\n      await copyDirectory(reportDir, path.join(runArchiveDir, 'reports'));\n    }\n    \n    // Create archive metadata\n    const metadata = {\n      timestamp: new Date().toISOString(),\n      commit: process.env.GITHUB_SHA || 'unknown',\n      branch: process.env.GITHUB_REF_NAME || 'unknown',\n      workflow: process.env.GITHUB_WORKFLOW || 'unknown',\n      runId: process.env.GITHUB_RUN_ID || 'unknown',\n      environment: {\n        node: process.version,\n        platform: process.platform,\n        arch: process.arch\n      }\n    };\n    \n    fs.writeFileSync(\n      path.join(runArchiveDir, 'metadata.json'),\n      JSON.stringify(metadata, null, 2)\n    );\n    \n    console.log(`üì¶ Artifacts archived to: ${runArchiveDir}`);\n    \n  } catch (error) {\n    console.warn('‚ö†Ô∏è  Could not archive artifacts:', error.message);\n  }\n}\n\n// Clean up temporary files\nasync function cleanupTempFiles() {\n  try {\n    const tempDirs = [\n      path.resolve(process.cwd(), 'playwright-results'),\n      path.resolve(process.cwd(), '.playwright')\n    ];\n    \n    for (const dir of tempDirs) {\n      if (fs.existsSync(dir) && !process.env.KEEP_TEMP_FILES) {\n        // Only clean up if not keeping temp files\n        try {\n          await removeDirectory(dir);\n          console.log(`üóëÔ∏è  Cleaned up: ${dir}`);\n        } catch (error) {\n          console.warn(`‚ö†Ô∏è  Could not clean up ${dir}: ${error.message}`);\n        }\n      }\n    }\n    \n  } catch (error) {\n    console.warn('‚ö†Ô∏è  Could not clean up temporary files:', error.message);\n  }\n}\n\n// Utility function to copy directory recursively\nasync function copyDirectory(src, dest) {\n  if (!fs.existsSync(dest)) {\n    fs.mkdirSync(dest, { recursive: true });\n  }\n  \n  const entries = fs.readdirSync(src, { withFileTypes: true });\n  \n  for (const entry of entries) {\n    const srcPath = path.join(src, entry.name);\n    const destPath = path.join(dest, entry.name);\n    \n    if (entry.isDirectory()) {\n      await copyDirectory(srcPath, destPath);\n    } else {\n      fs.copyFileSync(srcPath, destPath);\n    }\n  }\n}\n\n// Utility function to remove directory recursively\nasync function removeDirectory(dir) {\n  if (fs.rmSync) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  } else {\n    // Fallback for older Node versions\n    const rimraf = require('rimraf');\n    rimraf.sync(dir);\n  }\n}\n\nmodule.exports = globalTeardown;