const request = require('supertest');
const { app, db } = require('../src/app');

// Close the database connection after all tests
afterAll(() => {
  if (db) {
    db.close();
  }
});

describe('Security Tests', () => {
  beforeEach(() => {
    // Clean up tasks before each test
    try {
      db.prepare('DELETE FROM tasks').run();
    } catch (error) {
      // Table might not exist yet, ignore
    }
  });

  describe('Input Validation and Sanitization (FR-048)', () => {
    test('should sanitize HTML in task title', async () => {
      const maliciousTitle = '<script>alert(\"xss\")</script>Malicious Title';\n      \n      const response = await request(app)\n        .post('/api/tasks')\n        .send({ title: maliciousTitle });\n\n      expect(response.status).toBe(201);\n      // The title should be stored as-is but treated as text, not HTML\n      expect(response.body.title).toBe(maliciousTitle);\n      \n      // Verify it's stored correctly in the database\n      const getResponse = await request(app).get(`/api/tasks/${response.body.id}`);\n      expect(getResponse.body.title).toBe(maliciousTitle);\n    });\n\n    test('should sanitize HTML in task description', async () => {\n      const maliciousDescription = '<img src=x onerror=\"alert(1)\">Description';\n      \n      const response = await request(app)\n        .post('/api/tasks')\n        .send({ \n          title: 'Valid Title',\n          description: maliciousDescription \n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body.description).toBe(maliciousDescription);\n    });\n\n    test('should reject SQL injection attempts in title', async () => {\n      const sqlInjectionAttempts = [\n        \"'; DROP TABLE tasks; --\",\n        \"1' OR '1'='1\",\n        \"'; INSERT INTO tasks (title) VALUES ('injected'); --\"\n      ];\n\n      for (const injection of sqlInjectionAttempts) {\n        const response = await request(app)\n          .post('/api/tasks')\n          .send({ title: injection });\n\n        // Should either succeed (treating as regular text) or fail validation\n        // but should not cause database issues\n        expect([201, 400]).toContain(response.status);\n        \n        if (response.status === 201) {\n          // If accepted, verify it's stored as literal text\n          expect(response.body.title).toBe(injection);\n        }\n      }\n\n      // Verify tasks table still exists and functions\n      const tasksResponse = await request(app).get('/api/tasks');\n      expect(tasksResponse.status).toBe(200);\n    });\n\n    test('should validate and reject malformed JSON', async () => {\n      const response = await request(app)\n        .post('/api/tasks')\n        .set('Content-Type', 'application/json')\n        .send('{ \"title\": \"Incomplete JSON');\n\n      expect(response.status).toBe(400);\n    });\n\n    test('should validate required fields', async () => {\n      const invalidInputs = [\n        {}, // No title\n        { title: '' }, // Empty title\n        { title: '   ' }, // Whitespace only title\n        { title: null }, // Null title\n      ];\n\n      for (const input of invalidInputs) {\n        const response = await request(app)\n          .post('/api/tasks')\n          .send(input);\n\n        expect(response.status).toBe(400);\n        expect(response.body.error).toMatch(/title.*required/i);\n      }\n    });\n\n    test('should validate field length limits', async () => {\n      // Test title length limit (255 chars)\n      const longTitle = 'a'.repeat(256);\n      const titleResponse = await request(app)\n        .post('/api/tasks')\n        .send({ title: longTitle });\n\n      expect(titleResponse.status).toBe(400);\n      expect(titleResponse.body.error).toMatch(/title.*255/i);\n\n      // Test description length limit (1000 chars)\n      const longDescription = 'a'.repeat(1001);\n      const descResponse = await request(app)\n        .post('/api/tasks')\n        .send({ \n          title: 'Valid Title',\n          description: longDescription \n        });\n\n      expect(descResponse.status).toBe(400);\n      expect(descResponse.body.error).toMatch(/description.*1000/i);\n    });\n\n    test('should validate date formats', async () => {\n      const invalidDates = [\n        'invalid-date',\n        '2026-13-01', // Invalid month\n        '2026-02-30', // Invalid day\n        '2026/02/25', // Wrong format\n        '25-02-2026'  // Wrong format\n      ];\n\n      for (const invalidDate of invalidDates) {\n        const response = await request(app)\n          .post('/api/tasks')\n          .send({ \n            title: 'Valid Title',\n            dueDate: invalidDate \n          });\n\n        expect(response.status).toBe(400);\n        expect(response.body.error).toMatch(/date/i);\n      }\n    });\n  });\n\n  describe('CORS Configuration (FR-047)', () => {\n    test('should include proper CORS headers', async () => {\n      const response = await request(app)\n        .options('/api/tasks')\n        .set('Origin', 'http://localhost:3000');\n\n      expect(response.headers['access-control-allow-origin']).toBeDefined();\n      expect(response.headers['access-control-allow-methods']).toBeDefined();\n      expect(response.headers['access-control-allow-headers']).toBeDefined();\n    });\n\n    test('should handle preflight requests correctly', async () => {\n      const response = await request(app)\n        .options('/api/tasks')\n        .set('Origin', 'http://localhost:3000')\n        .set('Access-Control-Request-Method', 'POST')\n        .set('Access-Control-Request-Headers', 'Content-Type');\n\n      expect(response.status).toBe(204);\n    });\n  });\n\n  describe('Authentication and Authorization', () => {\n    // Note: Current implementation doesn't have auth, but these tests\n    // show where it would be tested when implemented\n    \n    test('should accept requests without authentication (current implementation)', async () => {\n      const response = await request(app).get('/api/tasks');\n      expect([200, 404]).toContain(response.status);\n    });\n\n    // Future auth tests would go here:\n    // test('should reject requests without valid token', async () => {\n    //   const response = await request(app).get('/api/tasks');\n    //   expect(response.status).toBe(401);\n    // });\n  });\n\n  describe('Error Information Disclosure (FR-057)', () => {\n    test('should not expose sensitive database information in errors', async () => {\n      // Try to trigger a database error\n      const response = await request(app)\n        .get('/api/tasks/999999999');\n\n      expect(response.status).toBe(404);\n      expect(response.body.error).toBe('Task not found');\n      \n      // Should not contain database schema info, file paths, or stack traces\n      const errorString = JSON.stringify(response.body);\n      expect(errorString).not.toMatch(/sqlite/i);\n      expect(errorString).not.toMatch(/table/i);\n      expect(errorString).not.toMatch(/column/i);\n      expect(errorString).not.toMatch(/\\/.*\\.js/); // File paths\n      expect(errorString).not.toMatch(/at.*\\(/); // Stack traces\n    });\n\n    test('should provide generic error messages for server errors', async () => {\n      // This would need to be tested with actual server errors\n      // For now, test the general principle with validation errors\n      const response = await request(app)\n        .post('/api/tasks')\n        .send({ title: '' });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toMatch(/title.*required/i);\n      \n      // Should not expose internal details\n      expect(response.body.error).not.toMatch(/sqlite/i);\n      expect(response.body.error).not.toMatch(/constraint/i);\n    });\n  });\n\n  describe('Request Size and Resource Limits', () => {\n    test('should handle reasonable request sizes', async () => {\n      const normalTask = {\n        title: 'Normal Task',\n        description: 'A'.repeat(500) // 500 chars is reasonable\n      };\n\n      const response = await request(app)\n        .post('/api/tasks')\n        .send(normalTask);\n\n      expect(response.status).toBe(201);\n    });\n\n    test('should reject oversized requests gracefully', async () => {\n      const oversizedTask = {\n        title: 'Oversized Task',\n        description: 'A'.repeat(10000), // Much larger than allowed\n        extraField: 'B'.repeat(50000) // Additional large field\n      };\n\n      const response = await request(app)\n        .post('/api/tasks')\n        .send(oversizedTask);\n\n      // Should either reject due to validation or size limits\n      expect([400, 413]).toContain(response.status);\n    });\n  });\n\n  describe('HTTP Method Security', () => {\n    test('should only allow appropriate HTTP methods', async () => {\n      // Test unsupported methods\n      const unsupportedMethods = ['PATCH', 'HEAD', 'TRACE', 'CONNECT'];\n      \n      // Note: PATCH is actually supported for /api/tasks/:id/status\n      // This test focuses on endpoints that shouldn't support certain methods\n      \n      const response = await request(app)\n        .trace('/api/tasks'); // TRACE should not be supported\n\n      expect([405, 404]).toContain(response.status); // Method not allowed or not found\n    });\n\n    test('should properly handle PUT vs POST semantics', async () => {\n      // POST should create new resources\n      const createResponse = await request(app)\n        .post('/api/tasks')\n        .send({ title: 'Test Task' });\n\n      expect(createResponse.status).toBe(201);\n      const taskId = createResponse.body.id;\n\n      // PUT should update existing resources\n      const updateResponse = await request(app)\n        .put(`/api/tasks/${taskId}`)\n        .send({ \n          title: 'Updated Task',\n          description: 'Updated description'\n        });\n\n      expect(updateResponse.status).toBe(200);\n\n      // PUT to non-existent resource should fail\n      const nonExistentResponse = await request(app)\n        .put('/api/tasks/999999')\n        .send({ title: 'Should fail' });\n\n      expect(nonExistentResponse.status).toBe(404);\n    });\n  });\n\n  describe('Content Type Validation', () => {\n    test('should require proper Content-Type for POST/PUT', async () => {\n      const response = await request(app)\n        .post('/api/tasks')\n        .send('title=Test Task') // Form data instead of JSON\n        .set('Content-Type', 'application/x-www-form-urlencoded');\n\n      // Should handle gracefully - either reject or parse correctly\n      expect([400, 415]).toContain(response.status);\n    });\n\n    test('should accept valid JSON Content-Type', async () => {\n      const response = await request(app)\n        .post('/api/tasks')\n        .send({ title: 'Valid JSON Task' })\n        .set('Content-Type', 'application/json');\n\n      expect(response.status).toBe(201);\n    });\n  });\n\n  describe('Rate Limiting Preparation (FR-050)', () => {\n    // Note: Rate limiting is not yet implemented, but these tests\n    // show how it would be tested when implemented\n    \n    test('should handle multiple requests without rate limiting (current)', async () => {\n      const requests = Array.from({ length: 10 }, () => \n        request(app).get('/api/tasks')\n      );\n\n      const responses = await Promise.all(requests);\n      \n      // All should succeed currently (no rate limiting implemented)\n      responses.forEach(response => {\n        expect(response.status).toBe(200);\n      });\n    });\n\n    // Future rate limiting tests:\n    // test('should implement rate limiting for API abuse prevention', async () => {\n    //   // Make many requests rapidly\n    //   const requests = Array.from({ length: 100 }, () => \n    //     request(app).get('/api/tasks')\n    //   );\n    //   \n    //   const responses = await Promise.all(requests);\n    //   const rateLimited = responses.filter(r => r.status === 429);\n    //   \n    //   expect(rateLimited.length).toBeGreaterThan(0);\n    // });\n  });\n});