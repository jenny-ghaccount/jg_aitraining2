const request = require('supertest');\nconst app = require('../../src/app');\nconst Database = require('better-sqlite3');\nconst path = require('path');\nconst fs = require('fs');\n\n// Test database setup\nlet db;\nlet testDbPath;\n\nbeforeAll(() => {\n  // Create a unique test database\n  testDbPath = path.join(__dirname, `test_advanced_${Date.now()}.db`);\n  db = new Database(testDbPath);\n  \n  // Override the app's database reference for testing\n  app.locals.db = db;\n  \n  // Create tasks table\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS tasks (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      title TEXT NOT NULL,\n      description TEXT DEFAULT '',\n      completed INTEGER DEFAULT 0,\n      dueDate TEXT DEFAULT NULL,\n      priority INTEGER DEFAULT 1,\n      tags TEXT DEFAULT '[]',\n      sortOrder INTEGER DEFAULT 0,\n      createdAt TEXT DEFAULT CURRENT_TIMESTAMP,\n      updatedAt TEXT DEFAULT CURRENT_TIMESTAMP\n    );\n    \n    CREATE INDEX IF NOT EXISTS idx_tasks_completed ON tasks(completed);\n    CREATE INDEX IF NOT EXISTS idx_tasks_dueDate ON tasks(dueDate);\n    CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);\n    CREATE INDEX IF NOT EXISTS idx_tasks_sortOrder ON tasks(sortOrder);\n  `);\n});\n\nafterAll(() => {\n  if (db) {\n    db.close();\n  }\n  if (fs.existsSync(testDbPath)) {\n    fs.unlinkSync(testDbPath);\n  }\n});\n\nbeforeEach(() => {\n  // Clear tasks table before each test\n  db.exec('DELETE FROM tasks');\n  db.exec('DELETE FROM sqlite_sequence WHERE name = \"tasks\"');\n});\n\n// Helper function to create sample tasks\nconst createSampleTasks = (count = 10) => {\n  const tasks = [];\n  const priorities = [1, 2, 3]; // Low, Medium, High\n  const statuses = [0, 1]; // Incomplete, Complete\n  \n  for (let i = 1; i <= count; i++) {\n    const task = {\n      title: `Task ${i}`,\n      description: `Description for task ${i}`,\n      completed: statuses[i % 2],\n      priority: priorities[i % 3],\n      dueDate: i % 3 === 0 ? new Date(Date.now() + (i * 24 * 60 * 60 * 1000)).toISOString() : null,\n      tags: JSON.stringify(i % 2 === 0 ? ['work', 'urgent'] : ['personal']),\n      sortOrder: i\n    };\n    \n    const stmt = db.prepare(`\n      INSERT INTO tasks (title, description, completed, priority, dueDate, tags, sortOrder)\n      VALUES (?, ?, ?, ?, ?, ?, ?)\n    `);\n    \n    const result = stmt.run(\n      task.title,\n      task.description,\n      task.completed,\n      task.priority,\n      task.dueDate,\n      task.tags,\n      task.sortOrder\n    );\n    \n    tasks.push({ ...task, id: result.lastInsertRowid });\n  }\n  \n  return tasks;\n};\n\ndescribe('Advanced API Endpoint Tests', () => {\n  describe('Pagination', () => {\n    beforeEach(() => {\n      createSampleTasks(25); // Create enough tasks for pagination testing\n    });\n\n    test('should paginate results with limit and offset', async () => {\n      const response = await request(app)\n        .get('/api/tasks?limit=10&offset=0')\n        .expect(200);\n\n      expect(response.body).toHaveProperty('tasks');\n      expect(response.body).toHaveProperty('total');\n      expect(response.body).toHaveProperty('page');\n      expect(response.body).toHaveProperty('totalPages');\n      \n      expect(response.body.tasks).toHaveLength(10);\n      expect(response.body.total).toBe(25);\n      expect(response.body.page).toBe(1);\n      expect(response.body.totalPages).toBe(3);\n    });\n\n    test('should return correct page 2 results', async () => {\n      const response = await request(app)\n        .get('/api/tasks?limit=10&offset=10')\n        .expect(200);\n\n      expect(response.body.tasks).toHaveLength(10);\n      expect(response.body.page).toBe(2);\n      expect(response.body.tasks[0].id).toBeGreaterThan(10);\n    });\n\n    test('should handle last page with partial results', async () => {\n      const response = await request(app)\n        .get('/api/tasks?limit=10&offset=20')\n        .expect(200);\n\n      expect(response.body.tasks).toHaveLength(5); // Only 5 tasks on last page\n      expect(response.body.page).toBe(3);\n    });\n\n    test('should validate pagination parameters', async () => {\n      // Negative limit\n      await request(app)\n        .get('/api/tasks?limit=-1')\n        .expect(400);\n\n      // Negative offset\n      await request(app)\n        .get('/api/tasks?offset=-1')\n        .expect(400);\n\n      // Limit too large\n      await request(app)\n        .get('/api/tasks?limit=1000')\n        .expect(400);\n    });\n\n    test('should handle empty results pagination', async () => {\n      db.exec('DELETE FROM tasks'); // Clear all tasks\n      \n      const response = await request(app)\n        .get('/api/tasks?limit=10&offset=0')\n        .expect(200);\n\n      expect(response.body.tasks).toHaveLength(0);\n      expect(response.body.total).toBe(0);\n      expect(response.body.totalPages).toBe(0);\n    });\n  });\n\n  describe('Advanced Filtering', () => {\n    beforeEach(() => {\n      createSampleTasks(20);\n    });\n\n    test('should filter by multiple criteria', async () => {\n      const response = await request(app)\n        .get('/api/tasks?completed=false&priority=3&tags=urgent')\n        .expect(200);\n\n      response.body.tasks.forEach(task => {\n        expect(task.completed).toBe(false);\n        expect(task.priority).toBe(3);\n        expect(JSON.parse(task.tags)).toContain('urgent');\n      });\n    });\n\n    test('should filter by date range', async () => {\n      const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n      const nextWeek = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\n      \n      const response = await request(app)\n        .get(`/api/tasks?dueDateAfter=${tomorrow}&dueDateBefore=${nextWeek}`)\n        .expect(200);\n\n      response.body.tasks.forEach(task => {\n        if (task.dueDate) {\n          expect(new Date(task.dueDate).getTime()).toBeGreaterThanOrEqual(new Date(tomorrow).getTime());\n          expect(new Date(task.dueDate).getTime()).toBeLessThanOrEqual(new Date(nextWeek).getTime());\n        }\n      });\n    });\n\n    test('should filter by text search in title and description', async () => {\n      const response = await request(app)\n        .get('/api/tasks?search=Task 1')\n        .expect(200);\n\n      response.body.tasks.forEach(task => {\n        const matchesTitle = task.title.toLowerCase().includes('task 1');\n        const matchesDescription = task.description.toLowerCase().includes('task 1');\n        expect(matchesTitle || matchesDescription).toBe(true);\n      });\n    });\n\n    test('should filter by creation date range', async () => {\n      const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n      const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n      \n      const response = await request(app)\n        .get(`/api/tasks?createdAfter=${yesterday}&createdBefore=${tomorrow}`)\n        .expect(200);\n\n      expect(response.body.tasks.length).toBeGreaterThan(0);\n    });\n\n    test('should combine filters with pagination', async () => {\n      const response = await request(app)\n        .get('/api/tasks?completed=false&limit=5&offset=0')\n        .expect(200);\n\n      expect(response.body.tasks).toHaveLength(5);\n      response.body.tasks.forEach(task => {\n        expect(task.completed).toBe(false);\n      });\n    });\n  });\n\n  describe('Advanced Sorting', () => {\n    beforeEach(() => {\n      createSampleTasks(15);\n    });\n\n    test('should sort by priority descending', async () => {\n      const response = await request(app)\n        .get('/api/tasks?sortBy=priority&sortOrder=desc')\n        .expect(200);\n\n      for (let i = 1; i < response.body.tasks.length; i++) {\n        expect(response.body.tasks[i-1].priority).toBeGreaterThanOrEqual(\n          response.body.tasks[i].priority\n        );\n      }\n    });\n\n    test('should sort by due date with nulls last', async () => {\n      const response = await request(app)\n        .get('/api/tasks?sortBy=dueDate&sortOrder=asc&nullsLast=true')\n        .expect(200);\n\n      let foundNull = false;\n      response.body.tasks.forEach((task, index) => {\n        if (task.dueDate === null) {\n          foundNull = true;\n        } else if (foundNull) {\n          // Once we've found a null, all subsequent tasks should also be null\n          expect(task.dueDate).toBe(null);\n        }\n      });\n    });\n\n    test('should sort by multiple criteria', async () => {\n      const response = await request(app)\n        .get('/api/tasks?sortBy=completed,priority&sortOrder=asc,desc')\n        .expect(200);\n\n      // First sort by completion status (asc), then by priority (desc)\n      for (let i = 1; i < response.body.tasks.length; i++) {\n        const prev = response.body.tasks[i-1];\n        const curr = response.body.tasks[i];\n        \n        if (prev.completed === curr.completed) {\n          // Same completion status, check priority order\n          expect(prev.priority).toBeGreaterThanOrEqual(curr.priority);\n        } else {\n          // Different completion status, incomplete should come first\n          expect(prev.completed).toBeLessThanOrEqual(curr.completed);\n        }\n      }\n    });\n\n    test('should handle custom sort order field', async () => {\n      const response = await request(app)\n        .get('/api/tasks?sortBy=sortOrder&sortOrder=asc')\n        .expect(200);\n\n      for (let i = 1; i < response.body.tasks.length; i++) {\n        expect(response.body.tasks[i-1].sortOrder).toBeLessThanOrEqual(\n          response.body.tasks[i].sortOrder\n        );\n      }\n    });\n  });\n\n  describe('Bulk Operations', () => {\n    beforeEach(() => {\n      createSampleTasks(10);\n    });\n\n    test('should update multiple tasks at once', async () => {\n      const taskIds = [1, 2, 3, 4, 5];\n      \n      const response = await request(app)\n        .patch('/api/tasks/bulk')\n        .send({\n          taskIds,\n          updates: {\n            completed: true,\n            priority: 3\n          }\n        })\n        .expect(200);\n\n      expect(response.body.updated).toBe(5);\n      \n      // Verify updates\n      for (const id of taskIds) {\n        const task = db.prepare('SELECT * FROM tasks WHERE id = ?').get(id);\n        expect(task.completed).toBe(1);\n        expect(task.priority).toBe(3);\n      }\n    });\n\n    test('should delete multiple tasks at once', async () => {\n      const taskIds = [1, 2, 3];\n      \n      const response = await request(app)\n        .delete('/api/tasks/bulk')\n        .send({ taskIds })\n        .expect(200);\n\n      expect(response.body.deleted).toBe(3);\n      \n      // Verify deletions\n      for (const id of taskIds) {\n        const task = db.prepare('SELECT * FROM tasks WHERE id = ?').get(id);\n        expect(task).toBeUndefined();\n      }\n    });\n\n    test('should reorder tasks', async () => {\n      const newOrder = [\n        { id: 3, sortOrder: 1 },\n        { id: 1, sortOrder: 2 },\n        { id: 2, sortOrder: 3 }\n      ];\n      \n      const response = await request(app)\n        .patch('/api/tasks/reorder')\n        .send({ tasks: newOrder })\n        .expect(200);\n\n      expect(response.body.updated).toBe(3);\n      \n      // Verify new order\n      const orderedTasks = db.prepare(\n        'SELECT id, sortOrder FROM tasks WHERE id IN (1, 2, 3) ORDER BY sortOrder'\n      ).all();\n      \n      expect(orderedTasks[0].id).toBe(3);\n      expect(orderedTasks[1].id).toBe(1);\n      expect(orderedTasks[2].id).toBe(2);\n    });\n\n    test('should validate bulk operation limits', async () => {\n      const manyTaskIds = Array.from({ length: 1001 }, (_, i) => i + 1);\n      \n      await request(app)\n        .patch('/api/tasks/bulk')\n        .send({\n          taskIds: manyTaskIds,\n          updates: { completed: true }\n        })\n        .expect(400)\n        .expect((res) => {\n          expect(res.body.error).toMatch(/too many tasks/i);\n        });\n    });\n  });\n\n  describe('Performance and Load Testing', () => {\n    test('should handle large result sets efficiently', async () => {\n      // Create a large number of tasks\n      createSampleTasks(1000);\n      \n      const startTime = Date.now();\n      \n      const response = await request(app)\n        .get('/api/tasks?limit=100')\n        .expect(200);\n\n      const endTime = Date.now();\n      const responseTime = endTime - startTime;\n      \n      expect(responseTime).toBeLessThan(1000); // Should complete within 1 second\n      expect(response.body.tasks).toHaveLength(100);\n    });\n\n    test('should handle concurrent requests without data corruption', async () => {\n      const concurrentRequests = Array.from({ length: 10 }, (_, i) => \n        request(app)\n          .post('/api/tasks')\n          .send({\n            title: `Concurrent Task ${i}`,\n            description: `Created by request ${i}`,\n            priority: (i % 3) + 1\n          })\n      );\n      \n      const responses = await Promise.all(concurrentRequests);\n      \n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(201);\n        expect(response.body).toHaveProperty('id');\n      });\n      \n      // Verify all tasks were created\n      const allTasks = db.prepare('SELECT COUNT(*) as count FROM tasks').get();\n      expect(allTasks.count).toBe(10);\n    });\n\n    test('should handle database connection limits gracefully', async () => {\n      // Simulate many concurrent database operations\n      const operations = [];\n      \n      for (let i = 0; i < 50; i++) {\n        operations.push(\n          request(app)\n            .get('/api/tasks')\n            .expect(200)\n        );\n      }\n      \n      const responses = await Promise.all(operations);\n      \n      // All operations should succeed\n      expect(responses).toHaveLength(50);\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    test('should handle malformed filter parameters', async () => {\n      await request(app)\n        .get('/api/tasks?priority=invalid')\n        .expect(400)\n        .expect((res) => {\n          expect(res.body.error).toMatch(/invalid priority/i);\n        });\n    });\n\n    test('should handle malformed date parameters', async () => {\n      await request(app)\n        .get('/api/tasks?dueDateAfter=not-a-date')\n        .expect(400)\n        .expect((res) => {\n          expect(res.body.error).toMatch(/invalid date/i);\n        });\n    });\n\n    test('should handle SQL injection attempts in search', async () => {\n      const maliciousSearch = \"'; DROP TABLE tasks; --\";\n      \n      const response = await request(app)\n        .get(`/api/tasks?search=${encodeURIComponent(maliciousSearch)}`)\n        .expect(200); // Should not cause an error\n\n      // Verify table still exists\n      const tableExists = db.prepare(\n        \"SELECT name FROM sqlite_master WHERE type='table' AND name='tasks'\"\n      ).get();\n      \n      expect(tableExists).toBeTruthy();\n    });\n\n    test('should handle database errors gracefully', async () => {\n      // Temporarily close database to simulate error\n      const originalDb = app.locals.db;\n      app.locals.db = null;\n      \n      await request(app)\n        .get('/api/tasks')\n        .expect(500)\n        .expect((res) => {\n          expect(res.body.error).toMatch(/database/i);\n        });\n      \n      // Restore database\n      app.locals.db = originalDb;\n    });\n\n    test('should handle non-existent task IDs in bulk operations', async () => {\n      const response = await request(app)\n        .patch('/api/tasks/bulk')\n        .send({\n          taskIds: [999, 1000, 1001], // Non-existent IDs\n          updates: { completed: true }\n        })\n        .expect(200);\n\n      expect(response.body.updated).toBe(0);\n    });\n\n    test('should validate required fields in bulk updates', async () => {\n      await request(app)\n        .patch('/api/tasks/bulk')\n        .send({\n          // Missing taskIds\n          updates: { completed: true }\n        })\n        .expect(400)\n        .expect((res) => {\n          expect(res.body.error).toMatch(/taskIds.*required/i);\n        });\n    });\n  });\n\n  describe('API Rate Limiting and Security', () => {\n    test('should enforce rate limits on task creation', async () => {\n      const rapidRequests = [];\n      \n      // Try to create many tasks rapidly\n      for (let i = 0; i < 100; i++) {\n        rapidRequests.push(\n          request(app)\n            .post('/api/tasks')\n            .send({\n              title: `Rapid Task ${i}`,\n              description: 'Rate limit test'\n            })\n        );\n      }\n      \n      const responses = await Promise.allSettled(rapidRequests);\n      \n      // Some requests should be rate limited (status 429)\n      const rateLimitedRequests = responses.filter(r => \n        r.status === 'fulfilled' && r.value.status === 429\n      );\n      \n      // Depending on rate limiting implementation\n      // expect(rateLimitedRequests.length).toBeGreaterThan(0);\n    });\n\n    test('should sanitize input data', async () => {\n      const maliciousData = {\n        title: '<script>alert(\"XSS\")</script>',\n        description: '<img src=\"x\" onerror=\"alert(1)\">',\n        tags: ['<script>', 'normal-tag']\n      };\n      \n      const response = await request(app)\n        .post('/api/tasks')\n        .send(maliciousData)\n        .expect(201);\n      \n      // Check that the data was sanitized\n      expect(response.body.title).not.toContain('<script>');\n      expect(response.body.description).not.toContain('<img');\n    });\n\n    test('should validate content length limits', async () => {\n      const veryLongTitle = 'x'.repeat(1001); // Assuming 1000 char limit\n      \n      await request(app)\n        .post('/api/tasks')\n        .send({\n          title: veryLongTitle,\n          description: 'Test'\n        })\n        .expect(400)\n        .expect((res) => {\n          expect(res.body.error).toMatch(/title.*too long/i);\n        });\n    });\n  });\n\n  describe('API Versioning and Backward Compatibility', () => {\n    test('should support API versioning headers', async () => {\n      const response = await request(app)\n        .get('/api/tasks')\n        .set('API-Version', 'v1')\n        .expect(200);\n\n      expect(response.headers['api-version']).toBeDefined();\n    });\n\n    test('should maintain backward compatibility for old task format', async () => {\n      // Create task with old format (without some new fields)\n      const oldFormatTask = {\n        title: 'Old Format Task',\n        completed: false\n        // Missing: description, priority, tags, etc.\n      };\n      \n      const response = await request(app)\n        .post('/api/tasks')\n        .send(oldFormatTask)\n        .expect(201);\n\n      // Should fill in default values\n      expect(response.body.description).toBeDefined();\n      expect(response.body.priority).toBeDefined();\n      expect(response.body.tags).toBeDefined();\n    });\n  });\n});